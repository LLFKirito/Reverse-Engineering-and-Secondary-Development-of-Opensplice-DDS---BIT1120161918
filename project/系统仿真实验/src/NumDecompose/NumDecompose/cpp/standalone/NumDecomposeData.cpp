//******************************************************************
// 
//  Generated by IDL to C++ Translator
//  
//  File name: NumDecomposeData.cpp
//  Source: NumDecomposeData.idl
//  Generated: Wed Nov  7 16:38:27 2018
//  OpenSplice 6.7.180404OSS
//  
//******************************************************************

#include "NumDecomposeData.h"


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< NumDecomposeData::NumSent::_num, NumDecomposeData::NumSent::_num_slice, struct NumDecomposeData::NumSent::_num_uniq_>;
template class DDS_DCPS_Array_forany< NumDecomposeData::NumSent::_num, NumDecomposeData::NumSent::_num_slice, struct NumDecomposeData::NumSent::_num_uniq_>;
#endif

template <>
NumDecomposeData::NumSent::_num_slice* DDS_DCPS_ArrayHelper < NumDecomposeData::NumSent::_num, NumDecomposeData::NumSent::_num_slice, NumDecomposeData::NumSent::_num_uniq_>::alloc ()
{
   return NumDecomposeData::NumSent::_num_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < NumDecomposeData::NumSent::_num, NumDecomposeData::NumSent::_num_slice, NumDecomposeData::NumSent::_num_uniq_>::copy (NumDecomposeData::NumSent::_num_slice *to, const NumDecomposeData::NumSent::_num_slice* from)
{
   NumDecomposeData::NumSent::_num_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < NumDecomposeData::NumSent::_num, NumDecomposeData::NumSent::_num_slice, NumDecomposeData::NumSent::_num_uniq_>::free (NumDecomposeData::NumSent::_num_slice *ptr)
{
   NumDecomposeData::NumSent::_num_free (ptr);
}

NumDecomposeData::NumSent::_num_slice * NumDecomposeData::NumSent::_num_alloc ()
{
   NumDecomposeData::NumDec * ret = (NumDecomposeData::NumDec*) new NumDecomposeData::NumDec [50];
   return (_num_slice *) ret;
}

void NumDecomposeData::NumSent::_num_free (_num_slice * s)
{
   delete [] s;
}

void NumDecomposeData::NumSent::_num_copy
(
   _num_slice * to,
   const _num_slice * from
)
{
   const NumDecomposeData::NumDec* sv = ( const NumDecomposeData::NumDec*) from;
   NumDecomposeData::NumDec* tv = (NumDecomposeData::NumDec*) to;
   for (DDS::ULong i = 0; i < 50; i++) tv[i] = sv[i];
}

NumDecomposeData::NumSent::_num_slice * NumDecomposeData::NumSent::_num_dup
   (const _num_slice * from)
{
   _num_slice * to = _num_alloc ();
   _num_copy (to, from);
   return to;
}


#if DDS_USE_EXPLICIT_TEMPLATES
template class DDS_DCPS_FArray_var< NumDecomposeData::NumDec::_factor, NumDecomposeData::NumDec::_factor_slice, struct NumDecomposeData::NumDec::_factor_uniq_>;
template class DDS_DCPS_Array_forany< NumDecomposeData::NumDec::_factor, NumDecomposeData::NumDec::_factor_slice, struct NumDecomposeData::NumDec::_factor_uniq_>;
#endif

template <>
NumDecomposeData::NumDec::_factor_slice* DDS_DCPS_ArrayHelper < NumDecomposeData::NumDec::_factor, NumDecomposeData::NumDec::_factor_slice, NumDecomposeData::NumDec::_factor_uniq_>::alloc ()
{
   return NumDecomposeData::NumDec::_factor_alloc ();
}

template <>
void DDS_DCPS_ArrayHelper < NumDecomposeData::NumDec::_factor, NumDecomposeData::NumDec::_factor_slice, NumDecomposeData::NumDec::_factor_uniq_>::copy (NumDecomposeData::NumDec::_factor_slice *to, const NumDecomposeData::NumDec::_factor_slice* from)
{
   NumDecomposeData::NumDec::_factor_copy (to, from);
}

template <>
void DDS_DCPS_ArrayHelper < NumDecomposeData::NumDec::_factor, NumDecomposeData::NumDec::_factor_slice, NumDecomposeData::NumDec::_factor_uniq_>::free (NumDecomposeData::NumDec::_factor_slice *ptr)
{
   NumDecomposeData::NumDec::_factor_free (ptr);
}

NumDecomposeData::NumDec::_factor_slice * NumDecomposeData::NumDec::_factor_alloc ()
{
   DDS::ULongLong * ret = (DDS::ULongLong*) new DDS::ULongLong [2];
   return (_factor_slice *) ret;
}

void NumDecomposeData::NumDec::_factor_free (_factor_slice * s)
{
   delete [] s;
}

void NumDecomposeData::NumDec::_factor_copy
(
   _factor_slice * to,
   const _factor_slice * from
)
{
   const DDS::ULongLong* sv = ( const DDS::ULongLong*) from;
   DDS::ULongLong* tv = (DDS::ULongLong*) to;
   for (DDS::ULong i = 0; i < 2; i++) tv[i] = sv[i];
}

NumDecomposeData::NumDec::_factor_slice * NumDecomposeData::NumDec::_factor_dup
   (const _factor_slice * from)
{
   _factor_slice * to = _factor_alloc ();
   _factor_copy (to, from);
   return to;
}




